#### 算法与思路
- 真二叉树的特点是每个非叶子结点都有左子树和右子树，所以对于根节点在前序序列的第一个，以及后序遍历的最后一个。根节点的左孩子在前序遍历中的第二个，根节点的右孩子在后序遍历中的倒数第二个。原理图如下：![photo](https://dsa.cs.tsinghua.edu.cn/oj/attachment/047a/047a8ca961ff072a77e1429242c82031dc92851f.png "真二叉树")
因此可以通过前序序列找到根节点的的左孩子，以及通过后序序列找到根节点的右孩子。那么可以在前序序列中找到后孩子的位置，以及后续遍历中找到根节点的左孩子。那么根节点的左子树的前序序列就是左孩子开始到有孩子的前一个，同理右子树的前序序列，以及左子树右子树的后序序列同样如此。只要确定了思路，那么代码就如此，直接递归即可。
#### 遇到的问题及解决办法
- 最开始我创建了二叉树的的结构，想用前序序列和后序序列构建二叉树，然后只需在用递归对二叉树进行中序遍历就能输出该真二叉树的中序序列。但在构建二叉树时，我发现既然已经能确定每个节点的值，那为什么不直接输出呢？于是，我直接试着在构建二叉树时直接输出二叉树的中序序列。那既然能直接输出二叉树的中序序列了，那就不需要再构建二叉树了，二叉树的结构就是多余的。于是我删除了二叉树的结构，直接再确定结点时就直接输出二叉树中序序列。对于每个根节点左右孩子的的位置下标，因为左子树或右子树的长度在前序序列和后序序列中是一样的，那么只要确定了左右孩子中的一个的下标，则另一个下标就可通过公式直接算出，省去了一次在前序序列或后序序列找结点的时间。改进后的程序见**程序代码**，具体实现写在了代码的注释中。
---
#### 时间复杂度和空间复杂度
- 该算法的时间复杂度即为构建二叉树的时间复杂度，但是不需要构建实际的二叉树结构。对于每个根节点左右孩子的的位置下标，因为左子树或右子树的长度在前序序列和后序序列中是一样的，那么只要确定了左右孩子中的一个的下标，则另一个下标就可通过公式$$i_r=por-(prr-i_l+1)$$直接算出，省去了一次在前序序列或后序序列找结点的时间。遍历结点的的时间复杂度为$O(n)$，每次递归需要找左右孩子下表中的一个，总的时间复杂度为$O(nlogn)$。空间复杂度只需要存储前序序列和后后序序列的空间以及递归调用的的额外空间，不需要二叉树的存储空间。
---
#### 程序代码
```c++
#include <iostream>
#include<cstdio>

using namespace std;

//不构建树，在递归时直接输出中序遍历，省去了构建树的时间，以及储存树的空间

void build(int *pre,int *post,int prl,int prr,int pol,int por)
{
    //pre是前序序列的数组，post是后序序列的数组
    //prl是当前结点结点为根的树的前序序列在pre的左下标，prr是右下标
    //pol是当前结点结点为根的树的前序序列在post的左下标，por是右下标
    //递归输出中序遍历
    int i;
    int j;
    if(prl==prr){//prl==prr表示已经是叶子节点，直接输出即可
        printf("%d ",pre[prl]);
        return;
    }else
    {
        i=prr;
        for(;pre[i]!=post[por-1];i--){}//在前序序列中从右向左查找右子树根节点的下标
        j=por-(prr-i+1);//通过右子树根节点的下标直接算出左子树根节点的下标
        build(pre,post,prl+1,i-1,pol,j-1);//递归调用继续遍历左子树
        printf("%d ",pre[prl]);//输出根节点
        build(pre,post,i,prr,j,por-1);//递归调用继续遍历右子树
    }
}
int main()
{
    setvbuf(stdin,new char[1<<20],_IOFBF,1<<20);
    setvbuf(stdout,new char[1<<20],_IOFBF,1<<20);
    int n;
    scanf("%d",&n);
    int *pre=new int[n];
    int *post=new int[n];
    //输入前序遍历
    for(int i=0;i<n;i++)
    {
        scanf("%d",&pre[i]);
    }
    //输入后续遍历
    for(int i=0;i<n;i++)
    {
        scanf("%d",&post[i]);
    }
    build(pre,post,0,n-1,0,n-1);//递归遍历二叉树
    printf("\n");
    return 0;
}

```