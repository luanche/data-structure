#### 算法与思路
- 这道题的一般思路是对每个点按x排序，然后对y进行遍历，如果$i_{y_1}>j_{y_2}\&\&y_1>y_2$则表明两个灯塔能够相互照亮，及逆序对。但对于y的遍历需要两个for循环嵌套，时间复杂度为$O(n^2)$这肯定会超时。而且这道题对于时间的要求挺高的，因此必须用别的算法。对于求逆序对、顺序随这样的题目，最好的算法就是归并排序，从下往上进行归并，在归并的同时，因为前后两个数组的元素基本有序，因此只要再后一个数组中找到刚好比前一个数组的某一个元素a大的元素b，则b后面的所有元素都比都比a大，这样就能加快求顺序对的效率。只要进行一次归并排序，归并排序结束，所有的逆序对就算出来了。
- 最开始我的思路不是用归并排序，我自己想了一个算法，坐标点使用链表储存的，以x对点排序，将第一个结点的指针存在指针数组中，然后从第一个结点开始往后找，找到第一个y值比它大的结点，将这个结点连在第一个结点后面，然后再以这个新找到的结点接着往后找，直到找到最后一个。每一个找出来的点都从链表中删除掉。然后接着从链表的第一个以前面的算法接着找，直到链表的所有元素都被找出来。相当于把一个链表分成了若干有序的链，则一个链的顺序对个数就能直接求出来，不同的链之间就和归并排序归并时一样，找出不同链之间的逆序对。但最后发现这样的算法，会一些结点之间的顺序信息丢失掉，找出的顺序对比正确答案少一点。然后我就把程序又改了，不是找结点后面第一个y比它大的结点将它链在后面，而是找结点后面一个结点，如果y比它大，着链再一起，如果不是，则从头开始找。这样不会丢失顺序信息，但是时间超了，这个算法确实比效率归并排序效率低。最后只能用归并排序实现。
---
#### 遇到的问题及解决办法
- 最开始我的思路不是用归并排序，我自己想了一个算法，坐标点使用链表储存的，以x对点排序，将第一个结点的指针存在指针数组中，然后从第一个结点开始往后找，找到第一个y值比它大的结点，将这个结点连在第一个结点后面，然后再以这个新找到的结点接着往后找，直到找到最后一个。每一个找出来的点都从链表中删除掉。然后接着从链表的第一个以前面的算法接着找，直到链表的所有元素都被找出来。相当于把一个链表分成了若干有序的链，则一个链的顺序对个数就能直接求出来，不同的链之间就和归并排序归并时一样，找出不同链之间的逆序对。但最后发现这样的算法，会一些结点之间的顺序信息丢失掉，找出的顺序对比正确答案少一点。然后我就把程序又改了，不是找结点后面第一个y比它大的结点将它链在后面，而是找结点后面一个结点，如果y比它大，着链再一起，如果不是，则从头开始找。这样不会丢失顺序信息，但是时间超了，这个算法确实比效率归并排序效率低。最后只能用归并排序实现。
---
#### 时间复杂度和空间复杂度
- 对x排序我是用的堆排序，时间复杂度为$O(nlogn)$，找逆序对用归并排序算法，效率也是$O(nlogn)$。但因为归并排序之前，将y单独拿出来，再进行排序，避免了结构体交换x，y都要换的问题，用$O(n)$的时间换了一半的$O(nlogn)$，空间复杂度时结构体的空间复杂度和存y值用的数组的空间复杂度，以及归并排序时用的辅助数组b的空间复杂度。
---
#### 程序代码
```c++

#include<cstdio>
#include <iostream>
#define N 4000001

using namespace std;

typedef long long ll;
typedef struct Point{
	ll x,y;
}Point;//坐标点结构体

ll *b=new ll[N];
ll y[N];

void adjust(Point *arr,int i,int length)//堆排序调整堆函数
{
    int k;
    Point temp;
    for(temp=arr[i];2*i+1<length;i=k)
    {
        k=2*i+1;
        if(k<length-1&&arr[k+1].x>arr[k].x) k++;
        if(temp.x<arr[k].x)
        {
            arr[i]=arr[k];
            arr[k]=temp;
        }
        else break;
    }
}

void sortArr(Point *arr,int len)//堆排序
{
    Point t;
    for(int i=len/2-1;i>=0;i--)
    {
        adjust(arr,i,len);
    }
    for(int i=len-1;i>0;i--)
    {
        t=arr[0];
        arr[0]=arr[i];
        arr[i]=t;
        adjust(arr,0,i);
    }
}
ll sum=0;
void Merge(ll *y,int l,int m,int h)
{
	ll *a=y+l,*c=y+m;
	int ib=m-l,ic=h-m;
	for(int i=0;i<ib;b[i]=a[i++]);
	for(int i=0,j=0,k=0;j<ib;)
	{
		if(ic<=k||b[j]<c[k])
        {
			a[i++]=b[j++];
			if(k<ic) sum+=ic-k;//求顺序对个数
		}
		if(k<ic&&c[k]<=b[j])a[i++]=c[k++];
	}
}


void mergeSort(ll *y,int lo,int hi)//归并排序
{
	if(hi-lo<2)return;
	int mi=(hi+lo)>>1;
	mergeSort(y,lo,mi);
	mergeSort(y,mi,hi);
	Merge(y,lo,mi,hi);
}
int main()
{
	int n;
	scanf("%d",&n);
	Point *ps=new Point[n];
	for(int i=0;i<n;i++)
    {
        scanf("%lld %lld",&ps[i].x,&ps[i].y);
    }
	sortArr(ps,n);//按x左边对结点进行排序
	for(int i=0;i<n;i++)
    {
        //因为后面需要将y进行归并排序，而x左边已经没有用了
        //所以将y去除单独放在数组y[]中，便于后面的归并排序求顺序对
        y[i]=ps[i].y;
    }
	mergeSort(y,0,n);//对y进行归并排序
	printf("%lld\n",sum);
	return 0;
}

```